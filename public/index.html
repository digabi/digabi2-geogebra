<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GeoGebra</title>
    <style>
      .outer {
        display: flex;
        flex-direction: column;
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      }
      .inner {
        flex: 1;
      }
      .GeoGebraFrame {
        border-width: 0 !important;
      }
      #saved-indicator {
        position: absolute;
        top: 17px;
        right: 150px;
        font-family: 'Arial', sans-serif;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        color: #173e82;
      }
    </style>
  </head>
  <body>
    <div class="outer">
      <div class="inner">
        <div id="ggb-element"></div>
        <div id="saved-indicator" />
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="GeoGebra/deployggb.js"></script>
    <script>
      // Lang query parameter is set by exam window container
      const search = new URLSearchParams(window.location.search)
      const lang = search.get('lang')
      localStorage.setItem('GeoGebraLangUI', lang)

      const config = new Map()
      const prefix = 'data:application/octet-stream;base64,'

      const path = () => `/wd/${encodeURIComponent(config.get('filename'))}`

      const savedIndicator = document.getElementById('saved-indicator')

      async function getFile() {
        const propfindResponse = await fetch(path(), { method: 'PROPFIND' })
        if (propfindResponse.status !== 207) {
          return ''
        }
        const response = await fetch(path())
        const data = await response.arrayBuffer()
        const url = await new Promise((resolve, reject) => {
          const reader = new FileReader()
          reader.onload = () => resolve(reader.result)
          reader.onerror = () => reject(reader.error)
          reader.readAsDataURL(new File([data], '', { type: 'application/octet-stream' }))
        })
        return url.substring(prefix.length)
      }

      async function getContentHash(base64Data) {
        if (!base64Data) return null

        try {
          // Extract zip file and compare content
          const binaryData = atob(base64Data)
          const zipBuffer = new Uint8Array(binaryData.length)
          for (let i = 0; i < binaryData.length; i++) {
            zipBuffer[i] = binaryData.charCodeAt(i)
          }

          // Use JSZip library to extract zip file
          const JSZip = window.JSZip
          if (!JSZip) {
            // Fallback: compare entire data if JSZip is not available
            const hashBuffer = await crypto.subtle.digest('SHA-256', zipBuffer)
            return Array.from(new Uint8Array(hashBuffer))
              .map(b => b.toString(16).padStart(2, '0'))
              .join('')
          }

          const zip = await JSZip.loadAsync(zipBuffer)
          const contentHash = {}

          // Collect content of all files
          for (const [filename, file] of Object.entries(zip.files)) {
            if (!file.dir) {
              const content = await file.async('text')
              contentHash[filename] = content
            }
          }

          // Create hash from content (without file names)
          const contentString = JSON.stringify(contentHash)
          const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(contentString))
          return Array.from(new Uint8Array(hashBuffer))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('')
        } catch (error) {
          console.error('Error processing zip:', error)
          // Fallback: compare entire data
          const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(base64Data))
          return Array.from(new Uint8Array(hashBuffer))
            .map(b => b.toString(16).padStart(2, '0'))
            .join('')
        }
      }

      let lastSavedData

      async function putFile(state) {
        const hashA = await getContentHash(lastSavedData)
        const hashB = await getContentHash(state)

        const contentChanged = hashA !== hashB

        if (!contentChanged) {
          return
        }
        savedIndicator.style.opacity = '0'
        const data = await fetch(`${prefix}${state}`)
        await fetch(path(), { method: 'PUT', body: await data.arrayBuffer() })
        lastSavedData = state

        switch (lang) {
          case 'fi-FI':
            savedIndicator.textContent = 'Tallennettu'
            break
          case 'sv-FI':
            savedIndicator.textContent = 'Sparat'
            break
          case 'en-Fi':
          default:
            savedIndicator.textContent = 'Saved'
            break
        }
        savedIndicator.style.opacity = '1'

        saveTimeout = setTimeout(() => {
          savedIndicator.style.opacity = '0'
        }, 2000)
      }

      function debounce(wait, callback) {
        let timeout
        return () => {
          window.clearTimeout(timeout)
          timeout = window.setTimeout(callback, wait)
        }
      }

      const resize = debounce(32, () => {
        if (window.ggbApplet) {
          ggbApplet.setSize(ggbElement.parentElement.clientWidth, ggbElement.parentElement.clientHeight)
        }
      })

      async function onLoad(event) {
        const args = new URLSearchParams(window.location.search)
        config.set('filename', args.get('filename'))

        const ggbElement = document.getElementById('ggb-element')
        window.ggbElement = ggbElement

        const ggbParams = {
          appName: 'classic',
          showToolbar: true,
          showAlgebraInput: true,
          showMenuBar: true,
          enableFileFeatures: false,
          useBrowserForJs: true,
          disableAutoScale: true,
          perspective: '1',
          width: ggbElement.parentElement.clientWidth,
          height: ggbElement.parentElement.clientHeight,
          borderRadius: 0,
          ggbBase64: await getFile(),
          appletOnLoad() {
            resize()
            lastSavedData = window.ggbApplet.getBase64()
          }
        }

        const applet = new GGBApplet(ggbParams, true)
        applet.setHTML5Codebase('GeoGebra/HTML5/5.0/web3d/')
        applet.inject(ggbElement.id)

        window.addEventListener('resize', resize)

        window.addEventListener('keydown', event => {
          if ((navigator.platform === 'MacIntel' ? event.metaKey : event.ctrlKey) && event.key === 's') {
            window.ggbApplet.getBase64(putFile)
            event.preventDefault()
          }
        })
        setInterval(() => putFile(window.ggbApplet.getBase64()), 3000)
      }

      window.addEventListener('load', onLoad)
    </script>
  </body>
</html>
